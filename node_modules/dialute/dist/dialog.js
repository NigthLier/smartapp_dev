"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.DialogManager = exports.Event = exports.dateLog = void 0;
const tslib_1 = require("tslib");
/* tslint:disable:max-classes-per-file */
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const api_1 = require("./api");
const Second = 1000;
const Minute = Second * 60;
function dateLog(msg) {
    console.log(`${chalk_1.default.cyanBright(new Date().toUTCString())} - ${msg}`);
}
exports.dateLog = dateLog;
var Event;
(function (Event) {
    Event["CreateSession"] = "CREATE_SESSION";
    Event["DeleteSession"] = "DELETE_SESSION";
})(Event = exports.Event || (exports.Event = {}));
class DialogManager {
    constructor(start, optional = {
        deleteSessionAfter: Minute * 4,
        deleteEachTime: Minute * 2,
    }) {
        this.start = start;
        this.sessions = {};
        this.deleteEachTime = optional.deleteEachTime;
        this.deleteSessionAfter = optional.deleteSessionAfter;
        this.hooks = {
            CREATE_SESSION: [],
            DELETE_SESSION: [],
        };
        // Important: setInterval changes context without wrapper function
        setInterval(() => this.deleteSessions(), this.deleteEachTime);
    }
    process(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!(request instanceof api_1.SberRequest)) {
                request = new api_1.SberRequest(request);
            }
            if (!this.sessions.hasOwnProperty(request.userId)) {
                const newSession = new Session(this.start, request);
                for (const hook of this.hooks[Event.CreateSession]) {
                    yield hook(newSession);
                }
                this.sessions[request.userId] = newSession;
            }
            const session = this.sessions[request.userId];
            session.request.clone(request);
            let rsp;
            const scriptStep = session.step();
            if (typeof scriptStep === 'string') {
                rsp = request.buildRsp();
                rsp.msg = scriptStep;
            }
            else if (scriptStep instanceof api_1.SberResponse) {
                rsp = scriptStep;
            }
            else if ({}.toString.call(scriptStep) === '[object Generator]') {
                session.script = scriptStep;
                rsp = yield this.process(request);
            }
            else if ({}.toString.call(scriptStep) === '[object GeneratorFunction]') {
                session.script = scriptStep(session.request, session.ctx);
                rsp = yield this.process(request);
            }
            else {
                dateLog(chalk_1.default.redBright('You have returned unsupported type from your generator'));
            }
            if (rsp.end) {
                delete this.sessions[request.userId];
            }
            return rsp;
        });
    }
    newHook(event, callback) {
        this.hooks[event].push(callback);
    }
    deleteSessions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const len = Object.keys(this.sessions).length;
            dateLog(chalk_1.default.magentaBright(`Total sessions: ${len}`));
            dateLog(chalk_1.default.magentaBright('Deleting unused sessions'));
            let counter = 0;
            for (const [key, value] of Object.entries(this.sessions)) {
                const s = value.lastActive;
                if (Date.now() - s > this.deleteSessionAfter) {
                    for (const hook of this.hooks[Event.CreateSession]) {
                        yield hook(this.sessions[key]);
                    }
                    delete this.sessions[key];
                    counter++;
                }
            }
            dateLog(chalk_1.default.magentaBright(`Deleted ${counter} sessions`));
        });
    }
}
exports.DialogManager = DialogManager;
class Session {
    constructor(start, request) {
        this.start = start;
        this.request = request;
        this.ctx = {};
        this.script = start(request, this.ctx);
        // this.scriptStorage = {'/': start};
        this.lastActive = Date.now();
    }
    step() {
        this.lastActive = Date.now();
        const { value, done } = this.script.next();
        if (done) {
            dateLog(chalk_1.default.bgYellow('Script ended. Reloading'));
            this.script = this.start(this.request, this.ctx);
            return this.step();
        }
        return value;
    }
}
exports.Session = Session;
//# sourceMappingURL=dialog.js.map