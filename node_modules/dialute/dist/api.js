"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SberResponse = exports.SberRequest = void 0;
class SberRequest {
    constructor(request) {
        this.body = request;
        if (this.type === 'MESSAGE_TO_SKILL') {
            this.nlu = new NLU(this.pld.message.tokenized_elements_list);
        }
    }
    get type() {
        return this.body.messageName;
    }
    get pld() {
        return this.body.payload;
    }
    get msg() {
        if (this.type === 'MESSAGE_TO_SKILL' || this.type === 'CLOSE_APP') {
            return this.pld.message.original_text;
        }
    }
    get msgFull() {
        if (this.type === 'MESSAGE_TO_SKILL' || this.type === 'CLOSE_APP') {
            return this.pld.message;
        }
    }
    get act() {
        if (this.type === 'SERVER_ACTION') {
            return this.pld.server_action;
        }
    }
    get char() {
        return this.pld.character;
    }
    get charGender() {
        return this.pld.character.gender;
    }
    get charName() {
        return this.pld.character.name;
    }
    get device() {
        return this.pld.device;
    }
    get userId() {
        // return this.body.sessionId; Always changes on SberPortal for each message!
        return this.body.uuid.userId;
        // return this.body.uuid.sub;
    }
    clone(another) {
        this.body = another.body;
        this.nlu = another.nlu;
    }
    buildRsp() {
        return new SberResponse(this);
    }
}
exports.SberRequest = SberRequest;
class SberResponse {
    constructor(request) {
        this.request = request;
        this.body = Object.assign(Object.assign({}, request.body), { payload: { device: request.device } });
        this.body.messageName = 'ANSWER_TO_USER';
        this.pld = this.body.payload;
        this.pld.items = [];
    }
    set msg(text) {
        this.pld.items = this.pld.items.filter((v) => !v.bubble);
        this.pld.items.push({ bubble: { text } });
        this.pld.pronounceText = text;
    }
    set msgJ(text) {
        if (this.request.pld.character.id === 'joy') {
            this.msg = text;
        }
    }
    set msgS(text) {
        if (this.request.pld.character.id === 'sber') {
            this.msg = text;
        }
    }
    set msgA(text) {
        if (this.request.pld.character.id === 'athena') {
            this.msg = text;
        }
    }
    set data(value) {
        this.pld.items = this.pld.items.filter((obj) => obj.command ? obj.command.type.smart_app_data : true);
        this.pld.items.push({
            command: { type: 'smart_app_data', smart_app_data: value },
        });
    }
    set act(value) {
        this.pld.items = this.pld.items.filter((obj) => obj.command ? obj.command.type.action : true);
        this.pld.items.push({ command: { type: 'action', action: value } });
    }
    set kbrd(buttons) {
        const formed = [];
        for (const button of buttons) {
            formed.push({ title: button, action: { text: button, type: 'text' } });
        }
        this.pld.suggestions = this.pld.suggestions || {};
        this.pld.suggestions.buttons = formed;
        // {'title': obj.text, 'action': {'text': obj.text, 'type': 'text'}}
    }
    set end(value) {
        this.pld.finished = value;
    }
    get end() {
        return this.pld.finished || false;
    }
    set listen(value) {
        this.pld.auto_listening = value;
    }
}
exports.SberResponse = SberResponse;
class Token {
    constructor(token) {
        this.part = token.grammem_info.part_of_speech;
        this.type = token.token_type;
        this.lemma = token.lemma;
        this.text = token.text;
    }
}
class NLU {
    constructor(elements) {
        this.tokens = [];
        this.lemmas = [];
        this.types = [];
        this.parts = [];
        this.texts = [];
        for (const element of elements) {
            if (!element.hasOwnProperty('grammem_info')) {
                continue;
            }
            const token = new Token(element);
            this.tokens.push(token);
            this.lemmas.push(token.lemma);
            this.types.push(token.type);
            this.parts.push(token.part);
            this.texts.push(token.text);
        }
    }
    lemmaIntersection(lemmas) {
        const lemmasSet = new Set(this.lemmas);
        let counter = 0;
        for (const lemma of lemmas) {
            if (lemmasSet.has(lemma)) {
                counter++;
            }
        }
        return counter;
    }
}
//# sourceMappingURL=api.js.map